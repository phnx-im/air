// SPDX-FileCopyrightText: 2024 Phoenix R&D GmbH <hello@phnx.im>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.36.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'mobile_logging.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// The type `DartNotifier` is not used by any `pub` functions, thus it is ignored.

String greet({required String name, dynamic hint}) =>
    RustLib.instance.api.crateDartApiGreet(name: name, hint: hint);

/// This is only to tell flutter_rust_bridge that it should expose the types
/// used in the parameters
Future<UiConversation> exposeConversation(
        {required UiConversation conversation, dynamic hint}) =>
    RustLib.instance.api
        .crateDartApiExposeConversation(conversation: conversation, hint: hint);

Future<UiNotificationType> exposeNotificationType(
        {required UiNotificationType notificationType, dynamic hint}) =>
    RustLib.instance.api.crateDartApiExposeNotificationType(
        notificationType: notificationType, hint: hint);

Future<void> deleteDatabases({required String clientDbPath, dynamic hint}) =>
    RustLib.instance.api
        .crateDartApiDeleteDatabases(clientDbPath: clientDbPath, hint: hint);

Stream<LogEntry> createLogStream({dynamic hint}) =>
    RustLib.instance.api.crateDartApiCreateLogStream(hint: hint);

Future<void> rustSetUp({dynamic hint}) =>
    RustLib.instance.api.crateDartApiRustSetUp(hint: hint);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RustUser>>
@sealed
class RustUser extends RustOpaque {
  RustUser.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  RustUser.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_RustUser,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_RustUser,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_RustUserPtr,
  );

  Future<void> addUsersToConversation(
          {required ConversationIdBytes conversationId,
          required List<String> userNames,
          dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserAddUsersToConversation(
          that: this,
          conversationId: conversationId,
          userNames: userNames,
          hint: hint);

  Future<UiContact?> contact({required String userName, dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserContact(
          that: this, userName: userName, hint: hint);

  Future<void> createConnection({required String userName, dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserCreateConnection(
          that: this, userName: userName, hint: hint);

  Future<ConversationIdBytes> createConversation(
          {required String name, dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserCreateConversation(
          that: this, name: name, hint: hint);

  Future<void> fetchMessages({dynamic hint}) => RustLib.instance.api
      .crateDartApiRustUserFetchMessages(that: this, hint: hint);

  /// This function is called from the flutter side to flush the debouncer
  /// state, immediately terminating the debouncer and marking all pending
  /// messages as read.
  Future<void> flushDebouncerState({dynamic hint}) => RustLib.instance.api
      .crateDartApiRustUserFlushDebouncerState(that: this, hint: hint);

  Future<List<UiContact>> getContacts({dynamic hint}) => RustLib.instance.api
      .crateDartApiRustUserGetContacts(that: this, hint: hint);

  Future<List<UiConversation>> getConversations({dynamic hint}) =>
      RustLib.instance.api
          .crateDartApiRustUserGetConversations(that: this, hint: hint);

  Future<List<UiConversationMessage>> getMessages(
          {required ConversationIdBytes conversationId,
          required int lastN,
          dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserGetMessages(
          that: this, conversationId: conversationId, lastN: lastN, hint: hint);

  /// This function is called from the flutter side to mark messages as read.
  ///
  /// The function is debounced and can be called multiple times in quick
  /// succession.
  Future<void> markMessagesAsReadDebounced(
          {required ConversationIdBytes conversationId,
          required BigInt timestamp,
          dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserMarkMessagesAsReadDebounced(
          that: this,
          conversationId: conversationId,
          timestamp: timestamp,
          hint: hint);

  /// Get a list of contacts to be added to the conversation with the given
  /// [`ConversationId`].
  Future<List<UiContact>> memberCandidates(
          {required ConversationIdBytes conversationId, dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserMemberCandidates(
          that: this, conversationId: conversationId, hint: hint);

  Future<List<String>> membersOfConversation(
          {required ConversationIdBytes conversationId, dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserMembersOfConversation(
          that: this, conversationId: conversationId, hint: hint);

  /// Get the own user profile.
  Future<UiUserProfile> ownUserProfile({dynamic hint}) => RustLib.instance.api
      .crateDartApiRustUserOwnUserProfile(that: this, hint: hint);

  Future<void> removeUsersFromConversation(
          {required ConversationIdBytes conversationId,
          required List<String> userNames,
          dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserRemoveUsersFromConversation(
          that: this,
          conversationId: conversationId,
          userNames: userNames,
          hint: hint);

  Future<UiConversationMessage> sendMessage(
          {required ConversationIdBytes conversationId,
          required String message,
          dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserSendMessage(
          that: this,
          conversationId: conversationId,
          message: message,
          hint: hint);

  Future<void> setConversationPicture(
          {required ConversationIdBytes conversationId,
          Uint8List? conversationPicture,
          dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserSetConversationPicture(
          that: this,
          conversationId: conversationId,
          conversationPicture: conversationPicture,
          hint: hint);

  Future<void> setUserProfile(
          {required String displayName,
          Uint8List? profilePictureOption,
          dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserSetUserProfile(
          that: this,
          displayName: displayName,
          profilePictureOption: profilePictureOption,
          hint: hint);

  Future<String> userName({dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserUserName(that: this, hint: hint);

  /// Get the user profile of the user with the given [`UserName`].
  Future<UiUserProfile?> userProfile(
          {required String userName, dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserUserProfile(
          that: this, userName: userName, hint: hint);

  Stream<WsNotification> websocket(
          {required int timeout, required int retryInterval, dynamic hint}) =>
      RustLib.instance.api.crateDartApiRustUserWebsocket(
          that: this,
          timeout: timeout,
          retryInterval: retryInterval,
          hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserBuilder>>
@sealed
class UserBuilder extends RustOpaque {
  UserBuilder.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  UserBuilder.sseDecode(BigInt ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_UserBuilder,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_UserBuilder,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_UserBuilderPtr,
  );

  Future<RustUser> createUser(
          {required String userName,
          required String password,
          required String address,
          required String path,
          dynamic hint}) =>
      RustLib.instance.api.crateDartApiUserBuilderCreateUser(
          that: this,
          userName: userName,
          password: password,
          address: address,
          path: path,
          hint: hint);

  /// Set the stream sink that will be used to send notifications to Dart. On
  /// the Dart side, this doesn't wait for the stream sink to be set
  /// internally, but immediately returns a stream. To confirm that the stream
  /// sink is set, this function sends a first notification to the Dart side.
  Stream<UiNotificationType> getStream({dynamic hint}) => RustLib.instance.api
      .crateDartApiUserBuilderGetStream(that: this, hint: hint);

  Future<RustUser> loadDefault({required String path, dynamic hint}) => RustLib
      .instance.api
      .crateDartApiUserBuilderLoadDefault(that: this, path: path, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<UserBuilder> newInstance({dynamic hint}) =>
      RustLib.instance.api.crateDartApiUserBuilderNew(hint: hint);
}

class U8Array16 extends NonGrowableListView<int> {
  static const arraySize = 16;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array16(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array16.init() : this(Uint8List(arraySize));
}

enum WsNotification {
  connected,
  disconnected,
  queueUpdate,
  ;
}
