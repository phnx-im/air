// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unreachable_switch_default, prefer_const_constructors
import 'package:convert/convert.dart';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'markdown.dart';
import 'message_content.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:uuid/uuid.dart';
part 'types.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `calculate`, `flight_break_condition`, `from_asset`, `from_bytes`, `from_draft`, `from_profile`, `from_user_id`, `into_draft`, `is_empty`, `load_from_conversation_type`, `new`, `timestamp`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ConversationId`, `ConversationMessageId`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UiChat>>
abstract class UiChat implements RustOpaqueInterface {
  UiChatAttributes get attributes;

  UiChatType get chatType;

  ChatId get id;

  UiChatStatus get status;

  set attributes(UiChatAttributes attributes);

  set chatType(UiChatType chatType);

  set id(ChatId id);

  set status(UiChatStatus status);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UiChatMessage>>
abstract class UiChatMessage implements RustOpaqueInterface {
  ChatId get conversationId;

  MessageId get id;

  UiMessage get message;

  UiFlightPosition get position;

  UiMessageStatus get status;

  String get timestamp;

  set conversationId(ChatId conversationId);

  set id(MessageId id);

  set message(UiMessage message);

  set position(UiFlightPosition position);

  set status(UiMessageStatus status);

  set timestamp(String timestamp);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UiConversationDetails>>
abstract class UiConversationDetails implements RustOpaqueInterface {
  UiChatAttributes get attributes;

  UiChatType get chatType;

  UiMessageDraft? get draft;

  ChatId get id;

  UiChatMessage? get lastMessage;

  String get lastUsed;

  int get messagesCount;

  UiChatStatus get status;

  int get unreadMessages;

  set attributes(UiChatAttributes attributes);

  set chatType(UiChatType chatType);

  set draft(UiMessageDraft? draft);

  set id(ChatId id);

  set lastMessage(UiChatMessage? lastMessage);

  set lastUsed(String lastUsed);

  set messagesCount(int messagesCount);

  set status(UiChatStatus status);

  set unreadMessages(int unreadMessages);
}

/// Image binary data together with its hashsum
class ImageData {
  /// The image data
  final Uint8List data;

  /// Opaque hash of the image data as hex string
  final String hash;

  const ImageData({required this.data, required this.hash});

  /// Computes opaque hashsum of the data and returns it as a hex string.
  static String computeHash(List<int> bytes) =>
      RustLib.instance.api.crateApiTypesImageDataComputeHash(bytes: bytes);

  @override
  int get hashCode => data.hashCode ^ hash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ImageData &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          hash == other.hash;
}

/// Attributes of a conversation
class UiChatAttributes {
  /// Title of the conversation
  final String title;

  /// Optional picture of the conversation
  final ImageData? picture;

  const UiChatAttributes({required this.title, this.picture});

  @override
  int get hashCode => title.hashCode ^ picture.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiChatAttributes &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          picture == other.picture;
}

@freezed
sealed class UiChatStatus with _$UiChatStatus {
  const UiChatStatus._();

  const factory UiChatStatus.inactive(UiInactiveConversation field0) =
      UiChatStatus_Inactive;
  const factory UiChatStatus.active() = UiChatStatus_Active;
}

@freezed
sealed class UiChatType with _$UiChatType {
  const UiChatType._();

  /// A connection conversation which was established via a handle and is not yet confirmed by
  /// the other party.
  const factory UiChatType.handleConnection(UiUserHandle field0) =
      UiChatType_HandleConnection;

  /// A connection conversation that is confirmed by the other party and for which we have
  /// received the necessary secrets.
  const factory UiChatType.connection(UiUserProfile field0) =
      UiChatType_Connection;

  /// A group conversation, that is, it can contains multiple participants.
  const factory UiChatType.group() = UiChatType_Group;
}

/// Client record of a user
///
/// Each user has a client record which identifies the users database.
class UiClientRecord {
  /// The unique identifier of the user
  ///
  /// Also used for identifying the client database path.
  final UiUserId userId;
  final DateTime createdAt;
  final UiUserProfile userProfile;
  final bool isFinished;

  const UiClientRecord({
    required this.userId,
    required this.createdAt,
    required this.userProfile,
    required this.isFinished,
  });

  @override
  int get hashCode =>
      userId.hashCode ^
      createdAt.hashCode ^
      userProfile.hashCode ^
      isFinished.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiClientRecord &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          createdAt == other.createdAt &&
          userProfile == other.userProfile &&
          isFinished == other.isFinished;
}

/// Contact of the logged-in user
class UiContact {
  final UiUserId userId;

  const UiContact({required this.userId});

  @override
  int get hashCode => userId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiContact &&
          runtimeType == other.runtimeType &&
          userId == other.userId;
}

/// Content of a message including the sender and whether it was sent
class UiContentMessage {
  final UiUserId sender;
  final bool sent;
  final UiMimiContent content;
  final bool edited;

  const UiContentMessage({
    required this.sender,
    required this.sent,
    required this.content,
    required this.edited,
  });

  @override
  int get hashCode =>
      sender.hashCode ^ sent.hashCode ^ content.hashCode ^ edited.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiContentMessage &&
          runtimeType == other.runtimeType &&
          sender == other.sender &&
          sent == other.sent &&
          content == other.content &&
          edited == other.edited;
}

/// Error message
class UiErrorMessage {
  final String message;

  const UiErrorMessage({required this.message});

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiErrorMessage &&
          runtimeType == other.runtimeType &&
          message == other.message;
}

@freezed
sealed class UiEventMessage with _$UiEventMessage {
  const UiEventMessage._();

  const factory UiEventMessage.system(UiSystemMessage field0) =
      UiEventMessage_System;
  const factory UiEventMessage.error(UiErrorMessage field0) =
      UiEventMessage_Error;
}

/// Position of a conversation message in a flight
///
/// A flight is a sequence of messages that are grouped to be displayed together.
enum UiFlightPosition {
  /// The message is the only message in the flight.
  single,

  /// The message is the first message in the flight and the flight has more than one message.
  start,

  /// The message is in the middle of the flight and the flight has more than one message.
  middle,

  /// The message is the last message in the flight and the flight has more than one message.
  end,
}

/// Inactive conversation with past members
class UiInactiveConversation {
  final List<UiUserId> pastMembers;

  const UiInactiveConversation({required this.pastMembers});

  @override
  int get hashCode => pastMembers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiInactiveConversation &&
          runtimeType == other.runtimeType &&
          pastMembers == other.pastMembers;
}

@freezed
sealed class UiMessage with _$UiMessage {
  const UiMessage._();

  const factory UiMessage.content(UiContentMessage field0) = UiMessage_Content;
  const factory UiMessage.display(UiEventMessage field0) = UiMessage_Display;
}

/// Draft of a message in a conversation
@freezed
sealed class UiMessageDraft with _$UiMessageDraft {
  const factory UiMessageDraft({
    required String message,
    MessageId? editingId,
    required DateTime updatedAt,
    required UiMessageDraftSource source,
  }) = _UiMessageDraft;
}

/// Makes it possible to distinguish whether the draft was created in Flutter by the user or loaded
/// from the database or reset by the handle, that is, by the system.
enum UiMessageDraftSource {
  /// The draft was created/changed by the user.
  user,

  /// The draft was created/changed by the system.
  system,
}

enum UiMessageStatus {
  sending,

  /// The message was sent to the server.
  sent,

  /// The message was received by at least one user in the conversation.
  delivered,

  /// The message was read by at least one user in the conversation.
  read,
}

@freezed
sealed class UiSystemMessage with _$UiSystemMessage {
  const UiSystemMessage._();

  const factory UiSystemMessage.add(UiUserId field0, UiUserId field1) =
      UiSystemMessage_Add;
  const factory UiSystemMessage.remove(UiUserId field0, UiUserId field1) =
      UiSystemMessage_Remove;
}

@freezed
sealed class UiUserHandle with _$UiUserHandle {
  const UiUserHandle._();
  const factory UiUserHandle({required String plaintext}) = _UiUserHandle;

  /// Returns `None` if the handle is valid, otherwise returns an error message why it is
  /// invalid.
  String? validationError() =>
      RustLib.instance.api.crateApiTypesUiUserHandleValidationError(that: this);
}

/// UI representation of an [`UserId`]
class UiUserId {
  final UuidValue uuid;
  final String domain;

  const UiUserId({required this.uuid, required this.domain});

  @override
  String toString() => '$uuid@$domain';

  @override
  int get hashCode => uuid.hashCode ^ domain.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiUserId &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid &&
          domain == other.domain;
}

/// Profile of a user
class UiUserProfile {
  /// ID of the user
  final UiUserId userId;

  /// Display name
  final String displayName;

  /// Optional profile picture
  final ImageData? profilePicture;

  const UiUserProfile({
    required this.userId,
    required this.displayName,
    this.profilePicture,
  });

  @override
  int get hashCode =>
      userId.hashCode ^ displayName.hashCode ^ profilePicture.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiUserProfile &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          displayName == other.displayName &&
          profilePicture == other.profilePicture;
}
