// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unreachable_switch_default, prefer_const_constructors
import 'package:convert/convert.dart';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'markdown.dart';
import 'message_content.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:uuid/uuid.dart';
part 'types.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `calculate`, `connection_user_id`, `flight_break_condition`, `from_asset`, `from_bytes`, `from_profile`, `from_user_id`, `load_from_chat_type`, `timestamp`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `UiChat`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `cmp`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `partial_cmp`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `from`

/// Mirror of the [`ChatId`] type
class ChatId {
  final UuidValue uuid;

  const ChatId({required this.uuid});

  @override
  String toString() => 'ChatId($uuid)';

  @override
  int get hashCode => uuid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChatId && runtimeType == other.runtimeType && uuid == other.uuid;
}

/// Image binary data together with its hashsum
///
/// Two images are considered equal in Dart if they have the same hashsum.
class ImageData {
  /// The image data
  final Uint8List data;

  /// Opaque hash of the image data as hex string
  final String hash;

  const ImageData({required this.data, required this.hash});

  /// Computes opaque hashsum of the data and returns it as a hex string.
  static String computeHash(List<int> bytes) =>
      RustLib.instance.api.crateApiTypesImageDataComputeHash(bytes: bytes);

  @override
  String toString() => 'ImageData(hash: $hash, len: ${data.length})';

  @override
  int get hashCode => hash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ImageData &&
          runtimeType == other.runtimeType &&
          hash == other.hash;
}

/// UI representation of a [`MessageDraft`]
@freezed
sealed class MessageDraft with _$MessageDraft {
  const factory MessageDraft({
    required String message,
    MessageId? editingId,
    required DateTime updatedAt,
    required bool isCommitted,
  }) = _MessageDraft;
}

/// Mirror of the [`MessageId`] type
class MessageId {
  final UuidValue uuid;

  const MessageId({required this.uuid});

  @override
  String toString() => 'MessageId($uuid)';

  @override
  int get hashCode => uuid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MessageId &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid;
}

/// Attributes of a chat
class UiChatAttributes {
  /// Title of the chat
  final String title;

  /// Optional picture of the chat
  final ImageData? picture;

  const UiChatAttributes({required this.title, this.picture});

  @override
  int get hashCode => title.hashCode ^ picture.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiChatAttributes &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          picture == other.picture;
}

/// Details of a chat
class UiChatDetails {
  final ChatId id;
  final UiChatStatus status;
  final UiChatType chatType;
  final String lastUsed;
  final UiChatAttributes attributes;
  final int messagesCount;
  final int unreadMessages;
  final UiChatMessage? lastMessage;
  final MessageDraft? draft;

  const UiChatDetails({
    required this.id,
    required this.status,
    required this.chatType,
    required this.lastUsed,
    required this.attributes,
    required this.messagesCount,
    required this.unreadMessages,
    this.lastMessage,
    this.draft,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      status.hashCode ^
      chatType.hashCode ^
      lastUsed.hashCode ^
      attributes.hashCode ^
      messagesCount.hashCode ^
      unreadMessages.hashCode ^
      lastMessage.hashCode ^
      draft.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiChatDetails &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          status == other.status &&
          chatType == other.chatType &&
          lastUsed == other.lastUsed &&
          attributes == other.attributes &&
          messagesCount == other.messagesCount &&
          unreadMessages == other.unreadMessages &&
          lastMessage == other.lastMessage &&
          draft == other.draft;
}

/// A message in a chat
@freezed
sealed class UiChatMessage with _$UiChatMessage {
  const factory UiChatMessage({
    required ChatId chatId,
    required MessageId id,
    required String timestamp,
    required UiMessage message,
    required UiFlightPosition position,
    required UiMessageStatus status,
  }) = _UiChatMessage;
}

@freezed
sealed class UiChatStatus with _$UiChatStatus {
  const UiChatStatus._();

  const factory UiChatStatus.inactive(UiInactiveChat field0) =
      UiChatStatus_Inactive;
  const factory UiChatStatus.active() = UiChatStatus_Active;
  const factory UiChatStatus.blocked() = UiChatStatus_Blocked;
}

@freezed
sealed class UiChatType with _$UiChatType {
  const UiChatType._();

  /// A connection chat which was established via a handle and is not yet confirmed by
  /// the other party.
  const factory UiChatType.handleConnection(UiUserHandle field0) =
      UiChatType_HandleConnection;

  /// A connection chat that is confirmed by the other party and for which we have
  /// received the necessary secrets.
  const factory UiChatType.connection(UiUserProfile field0) =
      UiChatType_Connection;

  /// A group chat, that is, it can contains multiple participants.
  const factory UiChatType.group() = UiChatType_Group;
}

/// Client record of a user
///
/// Each user has a client record which identifies the users database.
class UiClientRecord {
  /// The unique identifier of the user
  ///
  /// Also used for identifying the client database path.
  final UiUserId userId;
  final DateTime createdAt;
  final UiUserProfile userProfile;
  final bool isFinished;

  const UiClientRecord({
    required this.userId,
    required this.createdAt,
    required this.userProfile,
    required this.isFinished,
  });

  @override
  int get hashCode =>
      userId.hashCode ^
      createdAt.hashCode ^
      userProfile.hashCode ^
      isFinished.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiClientRecord &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          createdAt == other.createdAt &&
          userProfile == other.userProfile &&
          isFinished == other.isFinished;
}

/// Contact of the logged-in user
class UiContact {
  final UiUserId userId;

  const UiContact({required this.userId});

  @override
  int get hashCode => userId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiContact &&
          runtimeType == other.runtimeType &&
          userId == other.userId;
}

/// Content of a message including the sender and whether it was sent
@freezed
sealed class UiContentMessage with _$UiContentMessage {
  const factory UiContentMessage({
    required UiUserId sender,
    required bool sent,
    required UiMimiContent content,
    required bool edited,
  }) = _UiContentMessage;
}

/// Error message
@freezed
sealed class UiErrorMessage with _$UiErrorMessage {
  const factory UiErrorMessage({required String message}) = _UiErrorMessage;
}

@freezed
sealed class UiEventMessage with _$UiEventMessage {
  const UiEventMessage._();

  const factory UiEventMessage.system(UiSystemMessage field0) =
      UiEventMessage_System;
  const factory UiEventMessage.error(UiErrorMessage field0) =
      UiEventMessage_Error;
}

/// Position of a chat message in a flight
///
/// A flight is a sequence of messages that are grouped to be displayed together.
enum UiFlightPosition {
  /// The message is the only message in the flight.
  single,

  /// The message is the first message in the flight and the flight has more than one message.
  start,

  /// The message is in the middle of the flight and the flight has more than one message.
  middle,

  /// The message is the last message in the flight and the flight has more than one message.
  end,
}

/// Inactive chat with past members
class UiInactiveChat {
  final List<UiUserId> pastMembers;

  const UiInactiveChat({required this.pastMembers});

  @override
  int get hashCode => pastMembers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiInactiveChat &&
          runtimeType == other.runtimeType &&
          pastMembers == other.pastMembers;
}

@freezed
sealed class UiMessage with _$UiMessage {
  const UiMessage._();

  const factory UiMessage.content(UiContentMessage field0) = UiMessage_Content;
  const factory UiMessage.display(UiEventMessage field0) = UiMessage_Display;
}

enum UiMessageStatus {
  sending,

  /// The message was sent to the server.
  sent,

  /// The message was received by at least one user in the chat.
  delivered,

  /// The message was read by at least one user in the chat.
  read,

  /// The message was hidden because it is from a blocked contact.
  hidden,
}

@freezed
sealed class UiSystemMessage with _$UiSystemMessage {
  const UiSystemMessage._();

  const factory UiSystemMessage.add(UiUserId field0, UiUserId field1) =
      UiSystemMessage_Add;
  const factory UiSystemMessage.remove(UiUserId field0, UiUserId field1) =
      UiSystemMessage_Remove;
}

@freezed
sealed class UiUserHandle with _$UiUserHandle {
  const UiUserHandle._();
  const factory UiUserHandle({required String plaintext}) = _UiUserHandle;

  /// Returns `None` if the handle is valid, otherwise returns an error message why it is
  /// invalid.
  String? validationError() =>
      RustLib.instance.api.crateApiTypesUiUserHandleValidationError(that: this);
}

/// UI representation of an [`UserId`]
class UiUserId {
  final UuidValue uuid;
  final String domain;

  const UiUserId({required this.uuid, required this.domain});

  @override
  String toString() => '$uuid@$domain';

  @override
  int get hashCode => uuid.hashCode ^ domain.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiUserId &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid &&
          domain == other.domain;
}

/// Profile of a user
class UiUserProfile {
  /// ID of the user
  final UiUserId userId;

  /// Display name
  final String displayName;

  /// Optional profile picture
  final ImageData? profilePicture;

  const UiUserProfile({
    required this.userId,
    required this.displayName,
    this.profilePicture,
  });

  @override
  int get hashCode =>
      userId.hashCode ^ displayName.hashCode ^ profilePicture.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiUserProfile &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          displayName == other.displayName &&
          profilePicture == other.profilePicture;
}
