// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: unreachable_switch_default, prefer_const_constructors
import 'package:convert/convert.dart';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'markdown.dart';
import 'message_content.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:uuid/uuid.dart';
part 'types.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `calculate`, `flight_break_condition`, `from_asset`, `from_bytes`, `from_profile`, `from_simple`, `from_user_id`, `is_empty`, `load_from_conversation_type`, `new`, `timestamp`, `with_status`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `UiConversation`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`, `hash`

/// Mirror of the [`ConversationId`] type
class ConversationId {
  final UuidValue uuid;

  const ConversationId({required this.uuid});

  @override
  String toString() => 'ConversationId($uuid)';

  @override
  int get hashCode => uuid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversationId &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid;
}

/// Mirror of the [`ConversationMessageId`] type
class ConversationMessageId {
  final UuidValue uuid;

  const ConversationMessageId({required this.uuid});

  @override
  String toString() => 'ConversationMessageId($uuid)';

  @override
  int get hashCode => uuid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversationMessageId &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid;
}

/// Image binary data together with its hashsum
class ImageData {
  /// The image data
  final Uint8List data;

  /// Opaque hash of the image data as hex string
  final String hash;

  const ImageData({required this.data, required this.hash});

  /// Computes opaque hashsum of the data and returns it as a hex string.
  static String computeHash(List<int> bytes) =>
      RustLib.instance.api.crateApiTypesImageDataComputeHash(bytes: bytes);

  @override
  int get hashCode => data.hashCode ^ hash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ImageData &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          hash == other.hash;
}

/// Client record of a user
///
/// Each user has a client record which identifies the users database.
class UiClientRecord {
  /// The unique identifier of the user
  ///
  /// Also used for identifying the client database path.
  final UiUserId userId;
  final DateTime createdAt;
  final UiUserProfile userProfile;
  final bool isFinished;

  const UiClientRecord({
    required this.userId,
    required this.createdAt,
    required this.userProfile,
    required this.isFinished,
  });

  @override
  int get hashCode =>
      userId.hashCode ^
      createdAt.hashCode ^
      userProfile.hashCode ^
      isFinished.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiClientRecord &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          createdAt == other.createdAt &&
          userProfile == other.userProfile &&
          isFinished == other.isFinished;
}

/// Contact of the logged-in user
class UiContact {
  final UiUserId userId;

  const UiContact({required this.userId});

  @override
  int get hashCode => userId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiContact &&
          runtimeType == other.runtimeType &&
          userId == other.userId;
}

/// Content of a message including the sender and whether it was sent
class UiContentMessage {
  final UiUserId sender;
  final bool sent;
  final UiMimiContent content;

  const UiContentMessage({
    required this.sender,
    required this.sent,
    required this.content,
  });

  @override
  int get hashCode => sender.hashCode ^ sent.hashCode ^ content.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiContentMessage &&
          runtimeType == other.runtimeType &&
          sender == other.sender &&
          sent == other.sent &&
          content == other.content;
}

/// Attributes of a conversation
class UiConversationAttributes {
  /// Title of the conversation
  final String title;

  /// Optional picture of the conversation
  final ImageData? picture;

  const UiConversationAttributes({required this.title, this.picture});

  @override
  int get hashCode => title.hashCode ^ picture.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiConversationAttributes &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          picture == other.picture;
}

/// Details of a conversation
class UiConversationDetails {
  final ConversationId id;
  final UiConversationStatus status;
  final UiConversationType conversationType;
  final String lastUsed;
  final UiConversationAttributes attributes;
  final int messagesCount;
  final int unreadMessages;
  final UiConversationMessage? lastMessage;
  final UiMessageDraft? draft;

  const UiConversationDetails({
    required this.id,
    required this.status,
    required this.conversationType,
    required this.lastUsed,
    required this.attributes,
    required this.messagesCount,
    required this.unreadMessages,
    this.lastMessage,
    this.draft,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      status.hashCode ^
      conversationType.hashCode ^
      lastUsed.hashCode ^
      attributes.hashCode ^
      messagesCount.hashCode ^
      unreadMessages.hashCode ^
      lastMessage.hashCode ^
      draft.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiConversationDetails &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          status == other.status &&
          conversationType == other.conversationType &&
          lastUsed == other.lastUsed &&
          attributes == other.attributes &&
          messagesCount == other.messagesCount &&
          unreadMessages == other.unreadMessages &&
          lastMessage == other.lastMessage &&
          draft == other.draft;
}

/// A message in a conversation
class UiConversationMessage {
  final ConversationId conversationId;
  final ConversationMessageId id;
  final String timestamp;
  final UiMessage message;
  final UiFlightPosition position;
  final UiMessageStatus status;

  const UiConversationMessage({
    required this.conversationId,
    required this.id,
    required this.timestamp,
    required this.message,
    required this.position,
    required this.status,
  });

  @override
  int get hashCode =>
      conversationId.hashCode ^
      id.hashCode ^
      timestamp.hashCode ^
      message.hashCode ^
      position.hashCode ^
      status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiConversationMessage &&
          runtimeType == other.runtimeType &&
          conversationId == other.conversationId &&
          id == other.id &&
          timestamp == other.timestamp &&
          message == other.message &&
          position == other.position &&
          status == other.status;
}

@freezed
sealed class UiConversationStatus with _$UiConversationStatus {
  const UiConversationStatus._();

  const factory UiConversationStatus.inactive(UiInactiveConversation field0) =
      UiConversationStatus_Inactive;
  const factory UiConversationStatus.active() = UiConversationStatus_Active;
}

@freezed
sealed class UiConversationType with _$UiConversationType {
  const UiConversationType._();

  /// A connection conversation which was established via a handle and is not yet confirmed by
  /// the other party.
  const factory UiConversationType.handleConnection(UiUserHandle field0) =
      UiConversationType_HandleConnection;

  /// A connection conversation that is confirmed by the other party and for which we have
  /// received the necessary secrets.
  const factory UiConversationType.connection(UiUserProfile field0) =
      UiConversationType_Connection;

  /// A group conversation, that is, it can contains multiple participants.
  const factory UiConversationType.group() = UiConversationType_Group;
}

/// Error message
class UiErrorMessage {
  final String message;

  const UiErrorMessage({required this.message});

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiErrorMessage &&
          runtimeType == other.runtimeType &&
          message == other.message;
}

@freezed
sealed class UiEventMessage with _$UiEventMessage {
  const UiEventMessage._();

  const factory UiEventMessage.system(UiSystemMessage field0) =
      UiEventMessage_System;
  const factory UiEventMessage.error(UiErrorMessage field0) =
      UiEventMessage_Error;
}

/// Position of a conversation message in a flight
///
/// A flight is a sequence of messages that are grouped to be displayed together.
enum UiFlightPosition {
  /// The message is the only message in the flight.
  single,

  /// The message is the first message in the flight and the flight has more than one message.
  start,

  /// The message is in the middle of the flight and the flight has more than one message.
  middle,

  /// The message is the last message in the flight and the flight has more than one message.
  end,
}

/// Inactive conversation with past members
class UiInactiveConversation {
  final List<UiUserId> pastMembers;

  const UiInactiveConversation({required this.pastMembers});

  @override
  int get hashCode => pastMembers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiInactiveConversation &&
          runtimeType == other.runtimeType &&
          pastMembers == other.pastMembers;
}

@freezed
sealed class UiMessage with _$UiMessage {
  const UiMessage._();

  const factory UiMessage.content(UiContentMessage field0) = UiMessage_Content;
  const factory UiMessage.display(UiEventMessage field0) = UiMessage_Display;
}

/// Draft of a message in a conversation
@freezed
sealed class UiMessageDraft with _$UiMessageDraft {
  const factory UiMessageDraft({
    required String message,
    ConversationMessageId? editingId,
    required DateTime updatedAt,
  }) = _UiMessageDraft;
}

enum UiMessageStatus {
  sending,

  /// The message was sent to the server.
  sent,

  /// The message was received by at least one user in the conversation.
  delivered,

  /// The message was read by at least one user in the conversation.
  read,
}

@freezed
sealed class UiSystemMessage with _$UiSystemMessage {
  const UiSystemMessage._();

  const factory UiSystemMessage.add(UiUserId field0, UiUserId field1) =
      UiSystemMessage_Add;
  const factory UiSystemMessage.remove(UiUserId field0, UiUserId field1) =
      UiSystemMessage_Remove;
}

@freezed
sealed class UiUserHandle with _$UiUserHandle {
  const UiUserHandle._();
  const factory UiUserHandle({required String plaintext}) = _UiUserHandle;

  /// Returns `None` if the handle is valid, otherwise returns an error message why it is
  /// invalid.
  String? validationError() =>
      RustLib.instance.api.crateApiTypesUiUserHandleValidationError(that: this);
}

/// UI representation of an [`UserId`]
class UiUserId {
  final UuidValue uuid;
  final String domain;

  const UiUserId({required this.uuid, required this.domain});

  @override
  String toString() => '$uuid@$domain';

  @override
  int get hashCode => uuid.hashCode ^ domain.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiUserId &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid &&
          domain == other.domain;
}

/// Profile of a user
class UiUserProfile {
  /// ID of the user
  final UiUserId userId;

  /// Display name
  final String displayName;

  /// Optional profile picture
  final ImageData? profilePicture;

  const UiUserProfile({
    required this.userId,
    required this.displayName,
    this.profilePicture,
  });

  @override
  int get hashCode =>
      userId.hashCode ^ displayName.hashCode ^ profilePicture.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UiUserProfile &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          displayName == other.displayName &&
          profilePicture == other.profilePicture;
}
