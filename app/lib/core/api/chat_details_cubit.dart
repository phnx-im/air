// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unreachable_switch_default, prefer_const_constructors
import 'package:convert/convert.dart';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'markdown.dart';
import 'message_content.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:uuid/uuid.dart';
import 'types.dart';
import 'user_cubit.dart';
part 'chat_details_cubit.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `handle_store_notification`, `load_and_emit_state`, `load_chat_details`, `members_of_chat`, `new`, `spawn`, `store_draft_from_state`, `store_notifications_loop`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ChatDetailsContext`, `MarkAsReadState`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `hash`, `hash`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChatDetailsCubitBase>>
abstract class ChatDetailsCubitBase implements RustOpaqueInterface {
  Future<void> close();

  Future<void> editMessage({MessageId? messageId});

  bool get isClosed;

  /// Marks the chat as read until the given message id (including).
  ///
  /// The calls to this method are debounced with a fixed delay.
  Future<void> markAsRead({
    required MessageId untilMessageId,
    required DateTime untilTimestamp,
  });

  /// Creates a new cubit for the given chat.
  ///
  /// The cubit will fetch the chat details and the list of members. It will also listen to the
  /// changes in the chat and update the state accordingly.
  factory ChatDetailsCubitBase({
    required UserCubitBase userCubit,
    required ChatId chatId,
  }) => RustLib.instance.api.crateApiChatDetailsCubitChatDetailsCubitBaseNew(
    userCubit: userCubit,
    chatId: chatId,
  );

  Future<void> resetDraft();

  /// Sends a message to the chat.
  ///
  /// The not yet sent message is immediately stored in the local store and then the message is
  /// send to the DS.
  Future<void> sendMessage({required String messageText});

  /// Sets the chat picture.
  ///
  /// When `bytes` is `None`, the chat picture is removed.
  Future<void> setChatPicture({Uint8List? bytes});

  ChatDetailsState get state;

  Future<void> storeDraft({required String draftMessage});

  Stream<ChatDetailsState> stream();

  Future<void> uploadAttachment({required String path});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UiRoomState>>
abstract class UiRoomState implements RustOpaqueInterface {
  bool canKick({required UiUserId target});
}

/// The state of a single chat
///
/// Contains the chat details and the list of members.
///
/// Also see [`ChatDetailsCubitBase`].
@freezed
sealed class ChatDetailsState with _$ChatDetailsState {
  const ChatDetailsState._();
  const factory ChatDetailsState({
    UiChatDetails? chat,
    required List<UiUserId> members,
    UiRoomState? roomState,
  }) = _ChatDetailsState;
  static Future<ChatDetailsState> default_() =>
      RustLib.instance.api.crateApiChatDetailsCubitChatDetailsStateDefault();
}
