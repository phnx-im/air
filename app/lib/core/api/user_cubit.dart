// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unreachable_switch_default, prefer_const_constructors, camel_case_types
import 'package:convert/convert.dart';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'navigation_cubit.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:uuid/uuid.dart';
import 'types.dart';
import 'user.dart';

// These functions are ignored because they are not marked as `pub`: `chunks_to_strings`, `core_user`, `emit_stored_notifications`, `new`, `show_notifications`, `spawn_emit_stored_notifications`, `spawn_load`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `CubitContext`, `NotificationContext`, `UiUserInner`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `drop`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

class intArray12 extends NonGrowableListView<int> {
  static const arraySize = 12;

  @internal
  List<int> get inner => _inner;
  final List<int> _inner;

  intArray12(this._inner) : assert(_inner.length == arraySize), super(_inner);

  intArray12.init(int fill) : this(List<int>.filled(arraySize, fill));
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UiUser>>
abstract class UiUser implements RustOpaqueInterface {
  bool get unsupportedVersion;

  List<UiUserHandle> get userHandles;

  UiUserId get userId;
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserCubitBase>>
abstract class UserCubitBase implements RustOpaqueInterface {
  Future<ChatId> addContactFromGroup({
    required ChatId chatId,
    required UiUserId userId,
  });

  Future<bool> addUserHandle({required UiUserHandle userHandle});

  Future<void> addUserToChat(ChatId chatId, UiUserId userId);

  Future<List<UiContact>> addableContacts({required ChatId chatId});

  Future<void> blockContact({required UiUserId userId});

  Future<void> close();

  Future<UiContact?> contact({required UiUserId userId});

  Future<List<UiContact>> get contacts;

  Future<void> deleteAccount({
    required String dbPath,
    required String confirmationText,
  });

  Future<void> deleteChat(ChatId chatId);

  bool get isClosed;

  Future<void> leaveChat(ChatId chatId);

  factory UserCubitBase({
    required User user,
    required NavigationCubitBase navigation,
  }) => RustLib.instance.api.crateApiUserCubitUserCubitBaseNew(
    user: user,
    navigation: navigation,
  );

  Future<void> removeUserFromChat(ChatId chatId, UiUserId userId);

  Future<void> removeUserHandle({required UiUserHandle userHandle});

  Future<void> reportSpam({required UiUserId spammerId});

  /// Returns the pair of safety codes of the logged-in user and the given user.
  ///
  /// The order of the codes is stable and is determined by their lexicographical order.
  Future<intArray12> safetyCodes({required UiUserId otherUserId});

  Future<void> setAppState({required AppState appState});

  /// Set the display name and/or profile picture of the user.
  Future<void> setProfile({String? displayName, Uint8List? profilePicture});

  UiUser get state;

  Stream<UiUser> stream();

  Future<void> unblockContact({required UiUserId userId});
}

enum AppState { mobileBackground, desktopBackground, foreground }
